# X-CTF Platform

## Installation

### Initial Server Setup

#### Install System Dependencies

```bash
sudo apt update
sudo apt install -y \
    nginx \
    redis-server \
    docker.io \
    nftables \
    mysql-server \
    git
```

#### Start and Enable Services

```bash
sudo systemctl enable docker
sudo systemctl start docker
sudo systemctl enable redis
sudo systemctl start redis
sudo systemctl enable nginx
sudo systemctl enable nftables
sudo systemctl start nftables
```

### Set Up Python Environment

#### Install Conda/Miniconda

```bash
wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh
bash Miniconda3-latest-Linux-x86_64.sh
# Follow the installation prompts
# Restart your shell or: source ~/.bashrc
```

#### Create Conda Environment

```bash
conda env create -f env.yml
conda activate xctf-platform
```

### Set Up Database

#### MySQL

```bash
mysql -u root -p
CREATE DATABASE xctf;
EXIT;

python manage.py migrate
```

### Configure Redis

Edit `/etc/redis/redis.conf` and set a password:

```
requirepass your-redis-password
```

Restart Redis:

```bash
sudo systemctl restart redis
```

Make sure to update `REDIS_PASSWORD` in your `.env` file.

### Generate Configuration Files

Run the setup script to generate supervisor, uWSGI, and nginx configurations:

```bash
./setup-config.sh

# Create .env file
cp .env.example .env
nano .env  # Edit with your production values
```

### Static Files and Media

```bash
python manage.py collectstatic --noinput
```

### Start Services

#### Using Supervisor (Recommended)

```bash
supervisord -c supervisord.conf
supervisorctl -c supervisord.conf start all
supervisorctl -c supervisord.conf status
```

## Adding Challenges

1. Create a challenge directory in `$CHALLENGES_DIR`:
   ```
   $CHALLENGES_DIR/my-challenge/
   ├── challenge/
   │   └── (your challenge files)
   ├── Dockerfile
   └── metadata.json
   ```

2. Create `metadata.json`:
   ```json
   {
     "name": "My Challenge",
     "category": "Web",
     "points": 100,
     "flag": "FLAG_VALUE",
     "static": false,
     "tcp_ports": [8000]
   }
   ```

3. Create `Dockerfile` that exposes port 8000 (required):
   ```dockerfile
   FROM python:3.10-slim
   WORKDIR /app
   COPY challenge ./
   EXPOSE 8000
   CMD ["python", "app.py"]
   ```

4. Build and register the challenge:
   ```bash
   python manage.py setup_challenges --challenge-name my-challenge
   ```

## Challenge Port Mappings

- Each challenge must expose its main server at **port 8000** in the container
- Challenges can access their port mappings via `/data/.xctf_port_mappings.json` in the container

## Admin Panel

Access the admin panel at `/admin` (requires admin account).

Features:
- Edit challenge metadata
- Ban/unban users
- Send notifications to users
- Manage active Docker containers
- Redeploy challenges (refreshes all active sandboxes)

### Creating an Admin Account

Admin accounts must be created directly in the database:

```bash
python manage.py shell
>>> from user_auth.models import User
>>> admin, _ = User.objects.get_or_create(username='admin', email='admin@example.com', is_admin=True, verified=True)
>>> admin.set_password('your-password')
>>> admin.save()
```

## Configuration Files

The platform uses the following configuration files (generated by `setup-config.sh`):

- **supervisord.conf**
- **gunicorn_config.py**
- **nginx.conf**
- **.env.example**
- **flower_env.sh**

## Services

The platform runs the following services:

- **django-server**: uWSGI Flask application
- **celery-beat**: Celery scheduler
- **celery-worker-***: Celery worker processes (4 workers by default)
- **flower**: Celery monitoring dashboard

### TODO

- [ ] Explore SNAT for sandbox restrictions

### Post-Deployment Checklist

- [ ] SSL certificate installed and working
- [ ] All environment variables set correctly
- [ ] Database migrations applied
- [ ] Static files collected
- [ ] Admin user created
- [ ] Health check endpoint responding
- [ ] User registration and login working
- [ ] Email verification working
- [ ] Challenges accessible
- [ ] Admin panel accessible
- [ ] Logs being written correctly
- [ ] Firewall rules configured
- [ ] Rate limiting working
- [ ] All services running (check `supervisorctl -c supervisord.conf status` in conda environment)
